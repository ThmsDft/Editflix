<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Éditeur A4 - Export PNG</title>
    <!-- Lien pour charger la police Inter de Google Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700;800;900&display=swap"
      rel="stylesheet"
    />
    <style>
      /* Style global */
      body {
        margin: 0;
        padding: 0;
        display: flex;
        height: 100vh;
        background-color: #141414;
        font-family: "Inter", sans-serif;
        overflow: hidden;
      }

      /* Panneau de contrôles */
      #controls {
        width: 300px;
        padding: 20px;
        background-color: #141414;
        display: flex;
        flex-direction: column;
        gap: 4px;
        border-right: 1px solid #333;
      }

      /* Labels */
      #controls label {
        font-size: 13px;
        color: #bbb;
      }

      /* Style commun aux inputs, textarea et bouton */
      #controls input,
      #controls textarea {
        margin-bottom: 10px;
        padding: 10px;
        border: none;
        border-radius: 5px;
        background-color: #222;
        color: #fff;
        font-size: 14px;
        transition: background-color 0.3s ease;
        resize: none;
      }

      /* Effet focus */
      #controls input:focus,
      #controls textarea:focus {
        outline: none;
        background-color: #444444;
      }

      /* Style du bouton */
      #controls button {
        padding: 10px;
        border: none;
        border-radius: 5px;
        background-color: #e50914;
        color: #fff;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      #controls button:hover {
        background-color: #b20710;
      }

      /* Styles pour le bouton personnalisé du fichier */
      .custom-file {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .custom-file #custom-button {
        margin-bottom: 10px;
        padding: 10px;
        border: none;
        border-radius: 5px;
        background-color: #e50914;
        color: #fff;
        font-size: 12px;
        cursor: pointer;
        min-width: 130px;
      }
      .custom-file #custom-button:hover {
        background-color: #b20710;
      }
      .custom-file #custom-text {
        color: #fff;
        font-size: 12px;
      }

      /* Zone du canvas */
      #canvas-container {
        flex: 1;
        position: relative;
        overflow: hidden;
        background-color: #000;
      }

      canvas {
        background: #000;
        width: 100%;
        height: 100%;
      }

      /* Pour améliorer l'expérience utilisateur sur textarea */
      textarea {
        min-height: 100px;
      }

      /* Personnalisation de la scrollbar du textarea */
      /* Pour Firefox */
      textarea {
        scrollbar-width: thin;
        scrollbar-color: #e50914 #222; /* couleur de la "thumb" et de la piste */
      }

      /* Pour Chrome, Edge, Safari */
      textarea::-webkit-scrollbar {
        width: 8px;
      }

      textarea::-webkit-scrollbar-track {
        background: #222;
        border-radius:10px;
      }

      textarea::-webkit-scrollbar-thumb {
        background-color: #e50914;
        border-radius: 10px;
        border: px solid #222;
      }

      /* Personnalisation (ou suppression) des flèches dans les input number */
      /* Pour Firefox, on retire les flèches natives */
      input[type="number"] {
        -moz-appearance: textfield;
        appearance: textfield;
      }

      /* Pour Chrome, Edge, Safari : on masque les flèches natives */
      /* Si tu souhaites les personnaliser complètement, il faudra créer des boutons custom avec JS */
      input[type="number"]::-webkit-inner-spin-button,
      input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }

      /* Panneau de contrôles */
      #controls {
        width: 300px;
        padding: 20px;
        background-color: #141414;
        display: flex;
        flex-direction: column;
        gap: 4px;
        border-right: 1px solid #333;
        overflow-y: auto; /* Permet le défilement vertical */
      }

      /* Personnalisation de la scrollbar pour #controls */
      /* Pour Chrome, Edge, Safari */
      #controls::-webkit-scrollbar {
        width: 8px;
      }

      #controls::-webkit-scrollbar-track {
        background: #222;
        border-radius: 10px;
      }

      #controls::-webkit-scrollbar-thumb {
        background-color: #e50914;
        border-radius: 10px;
        border: 1px solid #222;
      }

      /* Pour Firefox */
      #controls {
        scrollbar-width: thin;
        scrollbar-color: #e50914 #222;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <label for="serie-title">Titre de la série</label>
      <input type="text" id="serie-title" value="Titre" />

      <label>Image de fond</label>
      <!-- Bouton personnalisé pour l'input file -->
      <div class="custom-file">
        <input type="file" id="photo" accept="image/*" style="display: none" />
        <button type="button" id="custom-button">Choisir un fichier</button>
        <span id="custom-text">Aucun fichier sélectionné</span>
      </div>

      <label for="recommendation">Pourcentage recommandé</label>
      <input type="number" id="recommendation" value="98" placeholder="98" />

      <label for="year">Année</label>
      <input type="number" id="year" value="2025" placeholder="2025" />

      <label for="rectangle-number">Âge recommandé</label>
      <input type="number" id="rectangle-number" value="12" placeholder="12" />

      <label for="rectangle-right-text">Avertissement de contenu</label>
      <input
        type="text"
        id="rectangle-right-text"
        value="crises, pleurs"
        placeholder="Texte à droite"
      />

      <label for="story-text">Synopsis</label>
      <textarea id="story-text" rows="4" placeholder="Synopsis">
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque fringilla eros tellus, nec elementum orci efficitur quis. Curabitur in efficitur enim. Fusce fermentum ultricies porttitor. Nunc consectetur tempus lacus a rhoncus. Morbi sit amet leo neque. Curabitur imperdiet augue justo, vel vehicula est malesuada ac.
      </textarea>

      <label for="distribution-text">Distribution</label>
      <input
        type="text"
        id="distribution-text"
        value="Juliann Dufourt, Thomas Dufourt, Laura Santos, plus"
        placeholder="Texte de distribution"
      />

      <label for="genres-text">Genres</label>
      <input
        type="text"
        id="genres-text"
        value="séries dramatiques, français"
        placeholder="Texte de genres"
      />

      <button id="export-png">Exporter en PNG</button>
    </div>
    <div id="canvas-container">
      <canvas id="editor"></canvas>
    </div>
    <script>
      // Dimensions de la feuille A4 pour l'affichage interactif
      const baseWidth = 600,
        baseHeight = 849;
      // Pour l'interactivité, position et échelle de la page dans le canvas
      let pageX = 0,
        pageY = 0,
        pageScale = 1;
      // Contenu dynamique
      let seriesTitle = "Titre",
        photo = null;

      // Chargement des images SVG
      let netflixSvgImage = new Image();
      netflixSvgImage.src = "netflix.svg";
      netflixSvgImage.onload = draw;

      let hdSvgImage = new Image();
      hdSvgImage.src = "HD.svg";
      hdSvgImage.onload = draw;

      let rectangleSvgImage = new Image();
      rectangleSvgImage.src = "rectangle.svg";
      rectangleSvgImage.onload = draw;

      let top10SvgImage = new Image();
      top10SvgImage.src = "Top10.svg";
      top10SvgImage.onload = draw;

      const canvas = document.getElementById("editor");
      const ctx = canvas.getContext("2d");

      // Fonction utilitaire pour envelopper du texte (monochrome)
      function wrapText(context, text, x, y, maxWidth, lineHeight) {
        const words = text.split(" ");
        let line = "";
        for (let n = 0; n < words.length; n++) {
          const testLine = line + words[n] + " ";
          if (context.measureText(testLine).width > maxWidth && n > 0) {
            context.fillText(line, x, y);
            line = words[n] + " ";
            y += lineHeight;
          } else {
            line = testLine;
          }
        }
        context.fillText(line, x, y);
      }

      // Fonctions de découpage et dessin du texte multi-couleur en alignement TOP,
      // ajoutant un espace entre les mots sur la même ligne, mais sans espace en début de ligne.
      function getWrappedLines(context, segments, maxWidth) {
        let words = [];
        segments.forEach((seg) => {
          let segWords = seg.text.split(" ");
          segWords.forEach((w) => {
            words.push({ text: w, style: seg.style });
          });
        });
        let lines = [];
        let currentLine = [];
        let currentLineWidth = 0;
        const spaceWidth = context.measureText(" ").width;
        words.forEach((word) => {
          const wordWidth = context.measureText(word.text).width;
          const additionalSpace = currentLine.length > 0 ? spaceWidth : 0;
          if (
            currentLineWidth + additionalSpace + wordWidth > maxWidth &&
            currentLine.length > 0
          ) {
            lines.push(currentLine);
            currentLine = [];
            currentLineWidth = 0;
          }
          if (currentLine.length > 0) {
            currentLine.push({ text: " ", style: word.style });
            currentLineWidth += spaceWidth;
          }
          currentLine.push(word);
          currentLineWidth += wordWidth;
        });
        if (currentLine.length > 0) {
          lines.push(currentLine);
        }
        return lines;
      }

      function drawWrappedMultiColorTextTop(
        context,
        segments,
        x,
        topY,
        maxWidth,
        lineHeight
      ) {
        context.font = "600 " + lineHeight / 1.2 + "px 'Inter', sans-serif";
        const lines = getWrappedLines(context, segments, maxWidth);
        lines.forEach((line, i) => {
          let currentX = x;
          let lineY = topY + i * lineHeight;
          line.forEach((word) => {
            context.fillStyle = word.style;
            context.fillText(word.text, currentX, lineY);
            currentX += context.measureText(word.text).width;
          });
        });
      }

      // Fonction de dessin principale
      function drawContent(context, pX, pY, scale) {
        const pageW = baseWidth * scale,
          pageH = baseHeight * scale;
        // Fond de la page (zone A4)
        context.fillStyle = "black";
        context.fillRect(pX, pY, pageW, pageH);

        // Image de fond et dégradé noir (80% de la hauteur)
        if (photo) {
          const targetWidth = pageW,
            targetHeight = pageH * 0.8,
            scaleFactor = Math.max(
              targetWidth / photo.width,
              targetHeight / photo.height
            ),
            imgW = photo.width * scaleFactor,
            imgH = photo.height * scaleFactor,
            imgX = pX + (targetWidth - imgW) / 2,
            imgY = pY + (targetHeight - imgH) / 2;
          context.save();
          context.beginPath();
          context.rect(pX, pY, targetWidth, targetHeight);
          context.clip();
          context.drawImage(photo, imgX, imgY, imgW, imgH);
          context.restore();

          const gradYStart = pY + pageH * 0.3,
            gradYEnd = pY + targetHeight * 1.01;
          let gradient = context.createLinearGradient(
            pX,
            gradYStart,
            pX,
            gradYEnd
          );
          gradient.addColorStop(0, "rgba(0, 0, 0, 0)");
          gradient.addColorStop(1, "rgba(0, 0, 0, 1)");
          context.fillStyle = gradient;
          context.fillRect(pX, gradYStart, targetWidth, gradYEnd - gradYStart);
        }

        // Titre de la série
        context.save();
        context.beginPath();
        context.rect(pX, pY, pageW, pageH);
        context.clip();
        context.fillStyle = "white";
        context.font = "900 " + 80 * scale + "px 'Inter', sans-serif";
        context.textBaseline = "bottom";
        let margin = 34 * scale;
        context.fillText(seriesTitle, pX + margin, pY + pageH - margin * 8.4);
        context.restore();

        // SVG Netflix
        if (
          netflixSvgImage.complete &&
          netflixSvgImage.naturalWidth &&
          netflixSvgImage.naturalHeight
        ) {
          const marginSvg = 35 * scale,
            desiredSvgWidth = 200 * scale,
            ratio =
              netflixSvgImage.naturalWidth / netflixSvgImage.naturalHeight,
            desiredSvgHeight = desiredSvgWidth / ratio,
            svgX = pX + marginSvg,
            svgY = pY + pageH - desiredSvgHeight - marginSvg * 7.2;
          context.drawImage(
            netflixSvgImage,
            svgX,
            svgY,
            desiredSvgWidth,
            desiredSvgHeight
          );
        }

        // Texte "Recommandé à XX % YYYY"
        context.save();
        context.font = "600 " + 11 * scale + "px 'Inter', sans-serif";
        context.textBaseline = "bottom";
        const recMargin = 35 * scale,
          recX = pX + recMargin,
          recY = pY + pageH - recMargin * 5.2,
          recText1 = "Recommandé à ",
          recPercentage =
            document.getElementById("recommendation").value || "98",
          recText2 = " %  ",
          recYear = document.getElementById("year").value || "2024";
        context.fillStyle = "#45D068";
        context.fillText(recText1, recX, recY);
        const width1 = context.measureText(recText1).width;
        context.fillText(recPercentage, recX + width1, recY);
        const width2 = context.measureText(recPercentage).width;
        context.fillText(recText2, recX + width1 + width2, recY);
        const width3 = context.measureText(recText2).width;
        context.fillStyle = "#B5B5B5";
        context.fillText(recYear, recX + width1 + width2 + width3, recY);
        const widthRecYear = context.measureText(recYear).width;
        context.restore();

        // SVG HD avec marge ajustée (10 * scale)
        if (
          hdSvgImage.complete &&
          hdSvgImage.naturalWidth &&
          hdSvgImage.naturalHeight
        ) {
          const iconAdditionalMargin = 5 * scale,
            iconX =
              recX +
              width1 +
              width2 +
              width3 +
              widthRecYear +
              iconAdditionalMargin,
            iconWidth = 16.3 * scale * 1.3,
            iconHeight =
              iconWidth * (hdSvgImage.naturalHeight / hdSvgImage.naturalWidth),
            iconY = recY - iconHeight * 1.05;
          context.drawImage(hdSvgImage, iconX, iconY, iconWidth, iconHeight);
        }

        // Bloc de texte "Distribution : ..." en alignement TOP
        const distributionWidth = baseWidth * 0.28 * scale,
          distributionX = pX + pageW - distributionWidth - recMargin,
          distributionFontSize = 8.8 * scale,
          distributionLineHeight = distributionFontSize * 1.2;
        const distributionDynamic =
          document.getElementById("distribution-text").value ||
          "Juliann Dufourt, Thomas Dufourt, Laura Santos, plus";
        const distributionSegments = [
          { text: "Distribution :", style: "#5F5F5F" },
          { text: " " + distributionDynamic, style: "#B5B5B5" },
        ];
        // Point de départ fixe en haut pour le bloc Distribution
        const distributionTopY = recY * 0.98;
        drawWrappedMultiColorTextTop(
          context,
          distributionSegments,
          distributionX,
          distributionTopY,
          distributionWidth,
          distributionLineHeight
        );

        // Calcul de la hauteur du bloc Distribution
        const distributionLines = getWrappedLines(
          context,
          distributionSegments,
          distributionWidth
        );
        const distributionBlockHeight =
          distributionLines.length * distributionLineHeight;

        // Bloc de texte "Genres : ..." en alignement TOP, placé sous Distribution
        const genresDynamic =
          document.getElementById("genres-text").value ||
          "séries dramatiques, français";
        const genresSegments = [
          { text: "Genres :", style: "#5F5F5F" },
          { text: " " + genresDynamic, style: "#B5B5B5" },
        ];
        const genresMargin = 13 * scale;
        const genresTopY =
          distributionTopY + distributionBlockHeight + genresMargin;
        drawWrappedMultiColorTextTop(
          context,
          genresSegments,
          distributionX,
          genresTopY,
          distributionWidth,
          distributionLineHeight
        );

        // Rectangle et textes associés
        if (
          rectangleSvgImage.complete &&
          rectangleSvgImage.naturalWidth &&
          rectangleSvgImage.naturalHeight
        ) {
          const rectMarginTop = 5 * scale,
            desiredRectWidth = 100 * scale * 0.28,
            desiredRectHeight =
              desiredRectWidth *
              (rectangleSvgImage.naturalHeight /
                rectangleSvgImage.naturalWidth),
            rectX = recX,
            rectY = recY + rectMarginTop;
          context.drawImage(
            rectangleSvgImage,
            rectX,
            rectY,
            desiredRectWidth,
            desiredRectHeight
          );
          const rectValue =
              document.getElementById("rectangle-number").value || "12",
            rectText = rectValue + "+";
          context.save();
          context.font =
            "bold " + desiredRectHeight * 0.6 + "px 'Inter', sans-serif";
          context.fillStyle = "#B5B5B5";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.fillText(
            rectText,
            rectX + desiredRectWidth / 2,
            rectY + desiredRectHeight / 2
          );
          context.restore();

          const rightText =
            document.getElementById("rectangle-right-text").value ||
            "crises, pleurs";
          context.save();
          context.font =
            "600 " + desiredRectHeight * 0.8 + "px 'Inter', sans-serif";
          context.fillStyle = "#B5B5B5";
          context.textAlign = "left";
          context.textBaseline = "middle";
          const marginBetween = 5 * scale;
          context.fillText(
            rightText,
            rectX + desiredRectWidth + marginBetween,
            rectY + desiredRectHeight / 2
          );
          context.restore();

          // Top10 SVG et texte associé
          if (
            top10SvgImage.complete &&
            top10SvgImage.naturalWidth &&
            top10SvgImage.naturalHeight
          ) {
            const top10MarginTop = 10 * scale,
              top10X = recX,
              top10Y = rectY + desiredRectHeight + top10MarginTop,
              desiredTop10Width = 18 * scale,
              desiredTop10Height =
                desiredTop10Width *
                (top10SvgImage.naturalHeight / top10SvgImage.naturalWidth);
            context.drawImage(
              top10SvgImage,
              top10X,
              top10Y,
              desiredTop10Width,
              desiredTop10Height
            );
            context.save();
            context.font =
              "600 " + desiredTop10Height * 0.72 + "px 'Inter', sans-serif";
            context.fillStyle = "white";
            context.textBaseline = "middle";
            const marginBetweenTop10 = 8 * scale,
              textX = top10X + desiredTop10Width + marginBetweenTop10,
              textY = top10Y + (desiredTop10Height / 2) * 1.1;
            context.fillText("N° 1 des séries TV aujourd’hui", textX, textY);
            context.restore();

            // Bloc de texte d'histoire
            const storyMarginTop = 30 * scale,
              storyX = recX,
              storyY = top10Y + desiredTop10Height + storyMarginTop,
              storyBoxWidth = pageW - recMargin * 8.2,
              storyFontSize = 10 * scale,
              storyLineHeight = storyFontSize * 1.2,
              storyText =
                document.getElementById("story-text").value ||
                "Suivez le parcours de Juliann, un enfant énergique et têtu de trois ans et demi, qui n'hésite pas à exprimer ses souhaits. Bien que la vie ne soit pas toujours facile, notamment lorsqu'il s'agit de gérer des parents bien intentionnés mais parfois maladroits, Juliann ne se décourage jamais et persévère jusqu'à l'obtention de ce qu'il désire vraiment.";
            context.save();
            context.font = storyFontSize + "px 'Inter', sans-serif";
            context.fillStyle = "white";
            wrapText(
              context,
              storyText,
              storyX,
              storyY,
              storyBoxWidth,
              storyLineHeight
            );
            context.restore();
          }
        }
      }

      // Fonction de dessin interactif
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#999";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawContent(ctx, pageX, pageY, pageScale);
      }

      // Redimensionnement du canvas interactif
      function resizeCanvas() {
        const container = document.getElementById("canvas-container");
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        if (pageX === 0 && pageY === 0) {
          pageX = (canvas.width - baseWidth * pageScale) / 2;
          pageY = (canvas.height - baseHeight * pageScale) / 2;
        }
        draw();
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // Événements pour la mise à jour dynamique
      document.getElementById("serie-title").addEventListener("input", (e) => {
        seriesTitle = e.target.value || "Titre";
        draw();
      });
      document.getElementById("recommendation").addEventListener("input", draw);
      document.getElementById("year").addEventListener("input", draw);
      document
        .getElementById("rectangle-number")
        .addEventListener("input", draw);
      document
        .getElementById("rectangle-right-text")
        .addEventListener("input", draw);
      document
        .getElementById("distribution-text")
        .addEventListener("input", draw);
      document.getElementById("genres-text").addEventListener("input", draw);
      document.getElementById("story-text").addEventListener("input", draw);

      // Bouton personnalisé : déclencher l'input file
      document.getElementById("custom-button").addEventListener("click", () => {
        document.getElementById("photo").click();
      });

      // Mise à jour de l'affichage du nom du fichier choisi
      document.getElementById("photo").addEventListener("change", (e) => {
        const file = e.target.files[0];
        const customText = document.getElementById("custom-text");
        if (file) {
          customText.textContent = file.name;
          photo = new Image();
          photo.onload = draw;
          photo.src = URL.createObjectURL(file);
        } else {
          customText.textContent = "Aucun fichier sélectionné";
        }
      });

      // Permettre le pan même en dehors du A4 et afficher le curseur en main
      let isDraggingPage = false,
        dragStartX,
        dragStartY;
      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        isDraggingPage = true;
        dragStartX = mouseX - pageX;
        dragStartY = mouseY - pageY;
        canvas.style.cursor = "grabbing";
      });
      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        if (isDraggingPage) {
          pageX = mouseX - dragStartX;
          pageY = mouseY - dragStartY;
          draw();
          canvas.style.cursor = "grabbing";
        } else {
          canvas.style.cursor = "grab";
        }
      });
      canvas.addEventListener("mouseup", () => {
        isDraggingPage = false;
        canvas.style.cursor = "grab";
      });
      canvas.addEventListener("mouseleave", () => {
        isDraggingPage = false;
        canvas.style.cursor = "grab";
      });

      // Permettre le zoom même si le curseur est en dehors du A4
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const zoomAmount = e.deltaY * -0.001;
        const newScale = Math.min(Math.max(pageScale + zoomAmount, 0.1), 3);
        const relX = mouseX - pageX;
        const relY = mouseY - pageY;
        pageX = mouseX - (relX * newScale) / pageScale;
        pageY = mouseY - (relY * newScale) / pageScale;
        pageScale = newScale;
        draw();
      });

      // Export PNG – création d'un canvas temporaire en haute résolution
      document.getElementById("export-png").addEventListener("click", () => {
        const exportMultiplier = 3;
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = baseWidth * exportMultiplier;
        tempCanvas.height = baseHeight * exportMultiplier;
        const tempCtx = tempCanvas.getContext("2d");
        tempCtx.scale(exportMultiplier, exportMultiplier);
        drawContent(tempCtx, 0, 0, 1);
        const link = document.createElement("a");
        link.href = tempCanvas.toDataURL("image/png");
        link.download = "document_a4.png";
        link.click();
      });
    </script>
  </body>
</html>
