<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NEXTFLIX</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700;800;900&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div id="controls">
      <img src="svg/Nextflix.svg" alt="Nextflix">
      <H1>Ta prochaine série, c’est toi</H1>
      <label for="serie-title">Titre de la série</label>
      <input type="text" id="serie-title" value="" />

      <label>Image de fond</label>
      <!-- Bouton personnalisé pour l'input file -->
      <div class="custom-file">
        <input type="file" id="photo" accept="image/*" style="display: none" />
        <button type="button" id="custom-button">Choisir un fichier</button>
        <span id="custom-text">Aucun fichier sélectionné</span>
      </div>

      <label for="recommendation">Pourcentage recommandé</label>
      <input type="number" id="recommendation" value="98" placeholder="98" />

      <label for="year">Année</label>
      <input type="number" id="year" value="2025" placeholder="2025" />

      <label for="rectangle-number">Âge recommandé</label>
      <input type="number" id="rectangle-number" value="12" placeholder="12" />

      <label for="rectangle-right-text">Avertissement de contenu</label>
      <input
        type="text"
        id="rectangle-right-text"
        value=""
        placeholder="Texte à droite"
      />

      <label for="story-text">Synopsis</label>
      <textarea id="story-text" rows="4" placeholder="Synopsis">
      </textarea>

      <label for="distribution-text">Distribution</label>
      <input
        type="text"
        id="distribution-text"
        value=""
        placeholder="Texte de distribution"
      />

      <label for="genres-text">Genres</label>
      <input
        type="text"
        id="genres-text"
        value="séries dramatiques, français"
        placeholder="Texte de genres"
      />

      <button id="export-png">Exporter en PNG</button>
    </div>
    <div id="canvas-container">
      <canvas id="editor"></canvas>
    </div>
    <script>
      // Dimensions de la feuille A4 pour l'affichage interactif
      const baseWidth = 600,
        baseHeight = 849;
      // Pour l'interactivité, position et échelle de la page dans le canvas
      let pageX = 0,
        pageY = 0,
        pageScale = 1;
      // Contenu dynamique
      let seriesTitle = "",
        photo = null;

      // Chargement des images SVG
      let netflixSvgImage = new Image();
      netflixSvgImage.src = "svg/netflix.svg";
      netflixSvgImage.onload = draw;

      let hdSvgImage = new Image();
      hdSvgImage.src = "svg/HD.svg";
      hdSvgImage.onload = draw;

      let rectangleSvgImage = new Image();
      rectangleSvgImage.src = "svg/rectangle.svg";
      rectangleSvgImage.onload = draw;

      let top10SvgImage = new Image();
      top10SvgImage.src = "svg/Top10.svg";
      top10SvgImage.onload = draw;

      const canvas = document.getElementById("editor");
      const ctx = canvas.getContext("2d");

      // Fonction utilitaire pour envelopper du texte (monochrome)
      function wrapText(context, text, x, y, maxWidth, lineHeight) {
        const words = text.split(" ");
        let line = "";
        for (let n = 0; n < words.length; n++) {
          const testLine = line + words[n] + " ";
          if (context.measureText(testLine).width > maxWidth && n > 0) {
            context.fillText(line, x, y);
            line = words[n] + " ";
            y += lineHeight;
          } else {
            line = testLine;
          }
        }
        context.fillText(line, x, y);
      }

      // Fonctions de découpage et dessin du texte multi-couleur en alignement TOP,
      // ajoutant un espace entre les mots sur la même ligne, mais sans espace en début de ligne.
      function getWrappedLines(context, segments, maxWidth) {
        let words = [];
        segments.forEach((seg) => {
          let segWords = seg.text.split(" ");
          segWords.forEach((w) => {
            words.push({ text: w, style: seg.style });
          });
        });
        let lines = [];
        let currentLine = [];
        let currentLineWidth = 0;
        const spaceWidth = context.measureText(" ").width;
        words.forEach((word) => {
          const wordWidth = context.measureText(word.text).width;
          const additionalSpace = currentLine.length > 0 ? spaceWidth : 0;
          if (
            currentLineWidth + additionalSpace + wordWidth > maxWidth &&
            currentLine.length > 0
          ) {
            lines.push(currentLine);
            currentLine = [];
            currentLineWidth = 0;
          }
          if (currentLine.length > 0) {
            currentLine.push({ text: " ", style: word.style });
            currentLineWidth += spaceWidth;
          }
          currentLine.push(word);
          currentLineWidth += wordWidth;
        });
        if (currentLine.length > 0) {
          lines.push(currentLine);
        }
        return lines;
      }

      function drawWrappedMultiColorTextTop(
        context,
        segments,
        x,
        topY,
        maxWidth,
        lineHeight
      ) {
        context.font = "600 " + lineHeight / 1.2 + "px 'Inter', sans-serif";
        const lines = getWrappedLines(context, segments, maxWidth);
        lines.forEach((line, i) => {
          let currentX = x;
          let lineY = topY + i * lineHeight;
          line.forEach((word) => {
            context.fillStyle = word.style;
            context.fillText(word.text, currentX, lineY);
            currentX += context.measureText(word.text).width;
          });
        });
      }

      // Fonction de dessin principale
      function drawContent(context, pX, pY, scale) {
        const pageW = baseWidth * scale,
          pageH = baseHeight * scale;
        // Fond de la page (zone A4)
        context.fillStyle = "black";
        context.fillRect(pX, pY, pageW, pageH);

        // Image de fond et dégradé noir (80% de la hauteur)
        if (photo) {
          const targetWidth = pageW,
            targetHeight = pageH * 0.8,
            scaleFactor = Math.max(
              targetWidth / photo.width,
              targetHeight / photo.height
            ),
            imgW = photo.width * scaleFactor,
            imgH = photo.height * scaleFactor,
            imgX = pX + (targetWidth - imgW) / 2,
            imgY = pY + (targetHeight - imgH) / 2;
          context.save();
          context.beginPath();
          context.rect(pX, pY, targetWidth, targetHeight);
          context.clip();
          context.drawImage(photo, imgX, imgY, imgW, imgH);
          context.restore();

          const gradYStart = pY + pageH * 0.3,
            gradYEnd = pY + targetHeight * 1.01;
          let gradient = context.createLinearGradient(
            pX,
            gradYStart,
            pX,
            gradYEnd
          );
          gradient.addColorStop(0, "rgba(0, 0, 0, 0)");
          gradient.addColorStop(1, "rgba(0, 0, 0, 1)");
          context.fillStyle = gradient;
          context.fillRect(pX, gradYStart, targetWidth, gradYEnd - gradYStart);
        }

        // Titre de la série
        context.save();
        context.beginPath();
        context.rect(pX, pY, pageW, pageH);
        context.clip();
        context.fillStyle = "white";
        context.font = "900 " + 80 * scale + "px 'Inter', sans-serif";
        context.textBaseline = "bottom";
        let margin = 34 * scale;
        context.fillText(seriesTitle, pX + margin, pY + pageH - margin * 8.4);
        context.restore();

        // SVG Netflix
        if (
          netflixSvgImage.complete &&
          netflixSvgImage.naturalWidth &&
          netflixSvgImage.naturalHeight
        ) {
          const marginSvg = 35 * scale,
            desiredSvgWidth = 200 * scale,
            ratio =
              netflixSvgImage.naturalWidth / netflixSvgImage.naturalHeight,
            desiredSvgHeight = desiredSvgWidth / ratio,
            svgX = pX + marginSvg,
            svgY = pY + pageH - desiredSvgHeight - marginSvg * 7.2;
          context.drawImage(
            netflixSvgImage,
            svgX,
            svgY,
            desiredSvgWidth,
            desiredSvgHeight
          );
        }

        // Texte "Recommandé à XX % YYYY"
        context.save();
        context.font = "600 " + 11 * scale + "px 'Inter', sans-serif";
        context.textBaseline = "bottom";
        const recMargin = 35 * scale,
          recX = pX + recMargin,
          recY = pY + pageH - recMargin * 5.2,
          recText1 = "Recommandé à ",
          recPercentage =
            document.getElementById("recommendation").value || "98",
          recText2 = " %  ",
          recYear = document.getElementById("year").value || "2024";
        context.fillStyle = "#45D068";
        context.fillText(recText1, recX, recY);
        const width1 = context.measureText(recText1).width;
        context.fillText(recPercentage, recX + width1, recY);
        const width2 = context.measureText(recPercentage).width;
        context.fillText(recText2, recX + width1 + width2, recY);
        const width3 = context.measureText(recText2).width;
        context.fillStyle = "#B5B5B5";
        context.fillText(recYear, recX + width1 + width2 + width3, recY);
        const widthRecYear = context.measureText(recYear).width;
        context.restore();

        // SVG HD avec marge ajustée (10 * scale)
        if (
          hdSvgImage.complete &&
          hdSvgImage.naturalWidth &&
          hdSvgImage.naturalHeight
        ) {
          const iconAdditionalMargin = 5 * scale,
            iconX =
              recX +
              width1 +
              width2 +
              width3 +
              widthRecYear +
              iconAdditionalMargin,
            iconWidth = 16.3 * scale * 1.3,
            iconHeight =
              iconWidth * (hdSvgImage.naturalHeight / hdSvgImage.naturalWidth),
            iconY = recY - iconHeight * 1.05;
          context.drawImage(hdSvgImage, iconX, iconY, iconWidth, iconHeight);
        }

        // Bloc de texte "Distribution : ..." en alignement TOP
        const distributionWidth = baseWidth * 0.28 * scale,
          distributionX = pX + pageW - distributionWidth - recMargin,
          distributionFontSize = 8.8 * scale,
          distributionLineHeight = distributionFontSize * 1.2;
        const distributionDynamic =
          document.getElementById("distribution-text").value ||
          "";
        const distributionSegments = [
          { text: "Distribution :", style: "#5F5F5F" },
          { text: " " + distributionDynamic, style: "#B5B5B5" },
        ];
        // Point de départ fixe en haut pour le bloc Distribution
        const distributionTopY = recY * 0.98;
        drawWrappedMultiColorTextTop(
          context,
          distributionSegments,
          distributionX,
          distributionTopY,
          distributionWidth,
          distributionLineHeight
        );

        // Calcul de la hauteur du bloc Distribution
        const distributionLines = getWrappedLines(
          context,
          distributionSegments,
          distributionWidth
        );
        const distributionBlockHeight =
          distributionLines.length * distributionLineHeight;

        // Bloc de texte "Genres : ..." en alignement TOP, placé sous Distribution
        const genresDynamic =
          document.getElementById("genres-text").value ||
          "";
        const genresSegments = [
          { text: "Genres :", style: "#5F5F5F" },
          { text: " " + genresDynamic, style: "#B5B5B5" },
        ];
        const genresMargin = 13 * scale;
        const genresTopY =
          distributionTopY + distributionBlockHeight + genresMargin;
        drawWrappedMultiColorTextTop(
          context,
          genresSegments,
          distributionX,
          genresTopY,
          distributionWidth,
          distributionLineHeight
        );

        // Rectangle et textes associés
        if (
          rectangleSvgImage.complete &&
          rectangleSvgImage.naturalWidth &&
          rectangleSvgImage.naturalHeight
        ) {
          const rectMarginTop = 5 * scale,
            desiredRectWidth = 100 * scale * 0.28,
            desiredRectHeight =
              desiredRectWidth *
              (rectangleSvgImage.naturalHeight /
                rectangleSvgImage.naturalWidth),
            rectX = recX,
            rectY = recY + rectMarginTop;
          context.drawImage(
            rectangleSvgImage,
            rectX,
            rectY,
            desiredRectWidth,
            desiredRectHeight
          );
          const rectValue =
              document.getElementById("rectangle-number").value || "16",
            rectText = rectValue + "+";
          context.save();
          context.font =
            "bold " + desiredRectHeight * 0.6 + "px 'Inter', sans-serif";
          context.fillStyle = "#B5B5B5";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.fillText(
            rectText,
            rectX + desiredRectWidth / 2,
            rectY + desiredRectHeight / 2
          );
          context.restore();

          const rightText =
            document.getElementById("rectangle-right-text").value ||
            "";
          context.save();
          context.font =
            "600 " + desiredRectHeight * 0.8 + "px 'Inter', sans-serif";
          context.fillStyle = "#B5B5B5";
          context.textAlign = "left";
          context.textBaseline = "middle";
          const marginBetween = 5 * scale;
          context.fillText(
            rightText,
            rectX + desiredRectWidth + marginBetween,
            rectY + desiredRectHeight / 2
          );
          context.restore();

          // Top10 SVG et texte associé
          if (
            top10SvgImage.complete &&
            top10SvgImage.naturalWidth &&
            top10SvgImage.naturalHeight
          ) {
            const top10MarginTop = 10 * scale,
              top10X = recX,
              top10Y = rectY + desiredRectHeight + top10MarginTop,
              desiredTop10Width = 18 * scale,
              desiredTop10Height =
                desiredTop10Width *
                (top10SvgImage.naturalHeight / top10SvgImage.naturalWidth);
            context.drawImage(
              top10SvgImage,
              top10X,
              top10Y,
              desiredTop10Width,
              desiredTop10Height
            );
            context.save();
            context.font =
              "600 " + desiredTop10Height * 0.72 + "px 'Inter', sans-serif";
            context.fillStyle = "white";
            context.textBaseline = "middle";
            const marginBetweenTop10 = 8 * scale,
              textX = top10X + desiredTop10Width + marginBetweenTop10,
              textY = top10Y + (desiredTop10Height / 2) * 1.1;
            context.fillText("N° 1 des séries TV aujourd’hui", textX, textY);
            context.restore();

            // Bloc de texte d'histoire
            const storyMarginTop = 30 * scale,
              storyX = recX,
              storyY = top10Y + desiredTop10Height + storyMarginTop,
              storyBoxWidth = pageW - recMargin * 8.2,
              storyFontSize = 10 * scale,
              storyLineHeight = storyFontSize * 1.2,
              storyText = document.getElementById("story-text").value || "";
            context.save();
            context.font = storyFontSize + "px 'Inter', sans-serif";
            context.fillStyle = "white";
            wrapText(
              context,
              storyText,
              storyX,
              storyY,
              storyBoxWidth,
              storyLineHeight
            );
            context.restore();
          }
        }
      }

      // Fonction de dessin interactif
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#999";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawContent(ctx, pageX, pageY, pageScale);
      }

      // Redimensionnement du canvas interactif
      function resizeCanvas() {
        const container = document.getElementById("canvas-container");
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        if (pageX === 0 && pageY === 0) {
          pageX = (canvas.width - baseWidth * pageScale) / 2;
          pageY = (canvas.height - baseHeight * pageScale) / 2;
        }
        draw();
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // Événements pour la mise à jour dynamique
      document.getElementById("serie-title").addEventListener("input", (e) => {
        seriesTitle = e.target.value || "";
        draw();
      });
      document.getElementById("recommendation").addEventListener("input", draw);
      document.getElementById("year").addEventListener("input", draw);
      document
        .getElementById("rectangle-number")
        .addEventListener("input", draw);
      document
        .getElementById("rectangle-right-text")
        .addEventListener("input", draw);
      document
        .getElementById("distribution-text")
        .addEventListener("input", draw);
      document.getElementById("genres-text").addEventListener("input", draw);
      document.getElementById("story-text").addEventListener("input", draw);

      // Bouton personnalisé : déclencher l'input file
      document.getElementById("custom-button").addEventListener("click", () => {
        document.getElementById("photo").click();
      });

      // Mise à jour de l'affichage du nom du fichier choisi
      document.getElementById("photo").addEventListener("change", (e) => {
        const file = e.target.files[0];
        const customText = document.getElementById("custom-text");
        if (file) {
          customText.textContent = file.name;
          photo = new Image();
          photo.onload = draw;
          photo.src = URL.createObjectURL(file);
        } else {
          customText.textContent = "Aucun fichier sélectionné";
        }
      });

      // Permettre le pan même en dehors du A4 et afficher le curseur en main
      let isDraggingPage = false,
        dragStartX,
        dragStartY;
      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        isDraggingPage = true;
        dragStartX = mouseX - pageX;
        dragStartY = mouseY - pageY;
        canvas.style.cursor = "grabbing";
      });
      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        if (isDraggingPage) {
          pageX = mouseX - dragStartX;
          pageY = mouseY - dragStartY;
          draw();
          canvas.style.cursor = "grabbing";
        } else {
          canvas.style.cursor = "grab";
        }
      });
      canvas.addEventListener("mouseup", () => {
        isDraggingPage = false;
        canvas.style.cursor = "grab";
      });
      canvas.addEventListener("mouseleave", () => {
        isDraggingPage = false;
        canvas.style.cursor = "grab";
      });

      // Permettre le zoom même si le curseur est en dehors du A4
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const zoomAmount = e.deltaY * -0.001;
        const newScale = Math.min(Math.max(pageScale + zoomAmount, 0.1), 3);
        const relX = mouseX - pageX;
        const relY = mouseY - pageY;
        pageX = mouseX - (relX * newScale) / pageScale;
        pageY = mouseY - (relY * newScale) / pageScale;
        pageScale = newScale;
        draw();
      });

      // Export PNG – création d'un canvas temporaire en haute résolution
      document.getElementById("export-png").addEventListener("click", () => {
        const exportMultiplier = 3;
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = baseWidth * exportMultiplier;
        tempCanvas.height = baseHeight * exportMultiplier;
        const tempCtx = tempCanvas.getContext("2d");
        tempCtx.scale(exportMultiplier, exportMultiplier);
        drawContent(tempCtx, 0, 0, 1);
        const link = document.createElement("a");
        link.href = tempCanvas.toDataURL("image/png");
        link.download = seriesTitle ? `${seriesTitle}.png` : "nextflix.png";
        link.click();
      });
    </script>

    <script>
      window.addEventListener("load", () => {
        fetch("exemples.json")
          .then((response) => response.json())
          .then((data) => {
            const exemples = data.exemples;
            const exempleChoisi =
              exemples[Math.floor(Math.random() * exemples.length)];

            // Mise à jour des inputs
            document.getElementById("serie-title").value =
              exempleChoisi.serieTitle;
            seriesTitle = exempleChoisi.serieTitle; // Mise à jour de la variable globale
            document.getElementById("serie-title").value =
              exempleChoisi.serieTitle;
            document.getElementById("recommendation").value =
              exempleChoisi.recommendation;
            document.getElementById("year").value = exempleChoisi.year;
            document.getElementById("rectangle-number").value =
              exempleChoisi["rectangle-number"];
            document.getElementById("rectangle-right-text").value =
              exempleChoisi["rectangle-right-text"];
            document.getElementById("story-text").value =
              exempleChoisi["story-text"];
            document.getElementById("distribution-text").value =
              exempleChoisi["distribution-text"];
            document.getElementById("genres-text").value =
              exempleChoisi["genres-text"];

            // Si une image de fond est définie dans le JSON, on la charge
            if (exempleChoisi.photo) {
              photo = new Image();
              photo.onload = draw; // redraw une fois l'image chargée
              photo.src = exempleChoisi.photo;
            } else {
              photo = null;
              draw();
            }
          })
          .catch((error) => {
            console.error("Erreur lors du chargement des exemples :", error);
            draw();
          });
      });
    </script>
  </body>
</html>
